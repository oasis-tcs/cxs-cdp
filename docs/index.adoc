= Customer Data Platform 1.0.0 : Working Draft
:toc: macro
:toc: right
:toclevels: 4
:sectnums:
:sourcedir: ../javascript

image::images/OASISLogo-v2.0.jpg["Oasis Open Logo"]

[discrete]
== Committee Specification Draft 01 / Public Review Draft 01 (Working Draft)

[discrete]
== Not Yet Published (18 October 2018)

////
[discrete]
=== Specification URIs:
This Version:

  * http://docs.oasis-open.org/cxs/cdp/v1.0/csprd01/cdp-v1.0-csprd01.adoc (Authoritative)
  * http://docs.oasis-open.org/cxs/cdp/v1.0/csprd01/cdp-v1.0-csprd01.html
  * http://docs.oasis-open.org/cxs/cdp/v1.0/csprd01/cdp-v1.0-csprd01.pdf

Previous Version:
  N/A

Latest Version:

  * http://docs.oasis-open.org/cxs/cdp/v1.0/cdp-v1.0.txt (Authoritative)
  * http://docs.oasis-open.org/cxs/cdp/v1.0/cdp-v1.0.html
  * http://docs.oasis-open.org/cxs/cdp/v1.0/cdp-v1.0.pdf
////

[discrete]
=== Technical Committee:

OASIS Context Server (CXS) TC

[discrete]
==== Chair(s):

  * Serge Huber (shuber@jahia.com), Jahia Solutions Group SA
  * Thomas Lund Sigdestad (tsi@enonic.com), Enonic

[discrete]
==== Editor(s):

  * Thomas Lund Sigdestad (tsi@enonic.com), Enonic
  * Serge Huber (shuber@jahia.com), Jahia Solutions Group SA

[discrete]
=== Additional artifacts:

This prose specification is one component of a Work Product that also includes:

  * GraphQL sample implementation: http://docs.oasis-open.org/tc-short-name/WP-abbrev/version/csdXX/schemas/ (hyperlink, including terminating /)
  * Other parts (list full title and VISIBLE hyperlink, preferably to HTML version)

[discrete]
=== Related work:

This specification is related to:

  * GraphQL : https://graphql.org
  * GraphQL specification : https://facebook.github.io/graphql/
  *	Related specifications (VISIBLE hyperlink, preferably to HTML version)

[discrete]
=== Abstract:

This specification aims to standardize exchange of customer data across systems and silos by defining a web-based API using GraphQL, thus providing a self-documented and strongly typed interface while allowing extensive customization. It is based upon four core concepts: Profiles, Events, Consents, and Clients.

[discrete]
=== Status:

This document was last revised or approved by the OASIS Context Server (CXS) TC on the above date. The level of approval is also listed above. Check the "Latest version" location noted above for possible later revisions of this document. Any other numbered Versions and other technical work produced by the Technical Committee (TC) are listed at https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=cxs#technical.

TC members should send comments on this specification to the TC's email list. Others should send comments to the TC's public comment list, after subscribing to it by following the instructions at the "Send A Comment" button on the TC's web page at https://www.oasis-open.org/committees/cxs/.

This specification is provided under the Non-Assertion Mode of the OASIS IPR Policy, the mode chosen when the Technical Committee was established. For information on whether any patents have been disclosed that may be essential to implementing this specification, and any offers of patent licensing terms, please refer to the Intellectual Property Rights section of the TC's web page (https://www.oasis-open.org/committees/cxs/ipr.php).

Note that any machine-readable content (Computer Language Definitions) declared Normative for this Work Product is provided in separate plain text files. In the event of a discrepancy between any such plain text file and display content in the Work Product's prose narrative document(s), the content in the separate plain text file prevails.

[discrete]
=== Citation format:

When referencing this specification the following citation format should be used:

*CDP-v1.0*

_Customer Data Platform Version 1.0_. Edited by Thomas Lund Sigdestad. 12 October 2018. OASIS Committee Specification Draft 01 / Public Review Draft 01. http://docs.oasis-open.org/cxs/cdp/v1.0/csprd01/cdp-v1.0-csprd01.html. Latest version: http://docs.oasis-open.org/cxs/cdp/v1.0/cdp-v1.0.html.


[discrete]
== Notices

Copyright © OASIS Open 2018. All Rights Reserved.

All capitalized terms in the following text have the meanings assigned to them in the OASIS Intellectual Property Rights Policy (the "OASIS IPR Policy"). The full Policy may be found at the OASIS website.

This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published, and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this section are included on all such copies and derivative works. However, this document itself may not be modified in any way, including by removing the copyright notice or references to OASIS, except as needed for the purpose of developing any document or deliverable produced by an OASIS Technical Committee (in which case the rules applicable to copyrights, as set forth in the OASIS IPR Policy, must be followed) or as required to translate it into languages other than English.

The limited permissions granted above are perpetual and will not be revoked by OASIS or its successors or assigns.

This document and the information contained herein is provided on an "AS IS" basis and OASIS DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY OWNERSHIP RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

OASIS requests that any OASIS Party or any other party that believes it has patent claims that would necessarily be infringed by implementations of this OASIS Committee Specification or OASIS Standard, to notify OASIS TC Administrator and provide an indication of its willingness to grant patent licenses to such patent claims in a manner consistent with the IPR Mode of the OASIS Technical Committee that produced this specification.

OASIS invites any party to contact the OASIS TC Administrator if it is aware of a claim of ownership of any patent claims that would necessarily be infringed by implementations of this specification by a patent holder that is not willing to provide a license to such patent claims in a manner consistent with the IPR Mode of the OASIS Technical Committee that produced this specification. OASIS may include such claims on its website, but disclaims any obligation to do so.

OASIS takes no posi tion regarding the validity or scope of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any effort to identify any such rights. Information on OASIS' procedures with respect to rights in any document or deliverable produced by an OASIS Technical Committee can be found on the OASIS website. Copies of claims of rights made available for publication and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this OASIS Committee Specification or OASIS Standard, can be obtained from the OASIS TC Administrator. OASIS makes no representation that any information or list of intellectual property rights will at any time be complete, or that any claims in such list are, in fact, Essential Claims.

The name "OASIS" is a trademark of OASIS, the owner and developer of this specification, and should be used only to refer to the organization and its official outputs. OASIS welcomes reference to, and implementation and use of, specifications, while reserving the right to enforce its marks against misleading uses. Please see https://www.oasis-open.org/policies-guidelines/trademark for above guidance.

toc::[]


== Introduction

Today, virtually all business is at some point digital, and the number of systems involved and the set of data collected is growing rapidly.
Each system creates new silos of customer data, spreading sensitive and personal data across both organizational and geographical borders.

Even digital savvy businesses struggle to control and utilize this information.
Businesses and users also rely on such data to be accessible in real-time, and at scale - for instance to deliver personalizations.
Additionally businesses now face severe legal charges if customer data is not treated according to regulatory requirements (ref GDPR).

The Customer Data Platform (CDP) specification aims to standardize exchange of customer data across systems and silos.
This enables centralization of customer data - consequently giving control of the data back to the business, and the customers.

The CDP standard builds upon four core concepts: Profiles, Events, Consents, and Clients

  * Profiles represent each individual "customer". Aggregating and tracking all registered properties, including which system actually collected the data.
  * Events represent user behavioral data / interactions performed by a customer (aka profile). A purchase, or a simple click on a link represents different events.
  * Consents are actual permission given by a customer to the organization, with a limited View and duration
  * Clients represent the various systems that provide and/or consume data from a Customer Data Platform, typical clients are: CRM systems, Identity Systems, Content Management Systems, E-commerce etc.

The CDP standard is defined as a web-based API using GraphQL - providing a self-documented and strongly typed interface.

It has been an explicit goal of the CXS committee to allow extensive customization of CDP deployments, in order to fit the need of each different organization.
As such, the API dynamically evolves as you customize your deployment.


=== Terminology

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119] and [RFC8174] when, and only when, they appear in all capitals, as shown here.

=== Normative References

  \[RFC2119]	Bradner, S., "Key words for use in RFCs to Indicate Requirement Levels", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.
  \[RFC8174]	Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <http://www.rfc-editor.org/info/rfc8174>.
  \[Reference]	\[Full reference citation]

=== Non-Normative References

  \[RFC3552]	Rescorla, E. and B. Korver, "Guidelines for Writing RFC Text on Security Considerations", BCP 72, RFC 3552, DOI 10.17487/RFC3552, July 2003, <https://www.rfc-editor.org/info/rfc3552>.
  \[Reference]	\[Full reference citation]


== Use Cases

In this section we present a few use cases that are relevant to the scope covered by the CDP specification. They are by
no means exhaustive and serve primarly as illustrations of what may be achieved using servers that implement the
standard.

=== Personalization

The first and most common use case is the case of delivering personalized experiences on (desktop or mobile) web sites.

image::images/cdp-webpersonalization-usecase.svg["Personalization use case diagram"]

As illustrated above, the browser can interact with both a Content Management System (CMS) and a CDP-compliant server
to first retrieve the HTML needed to deliver the page content. After this the next request to the CMS is a request
for personalized content that will be customized based on the profile retrieved from the CDP. The result is personalized
content for the current visitor being sent back to the browser.

This illustration is by no means the only way to implement personalization using a CDP but it serves as a simple
introduction to the possibilies such a system may offer.

=== Newsletters

This use case is relevant to users interested in delivering newsletters to the proper audience. For example it might be
interesting to send a newsletter to promote a product to a group of profiles that has not purchased the product before,
but it would not be a good idea to send it to people that have already purchased it.

image::images/cdp-newsletter-usecase.svg["Newsletter use case diagram"]

In the above illustration the newsletter server can query the CDP for a group of profile using either a query or a pre-
defined segment to retrieve the subset of profiles it is interested in. Once those profiles are retrieved they may be
used to update the newsletters management system lists with information coming from those exported profiles. And finally,
when the newsletter is ready to be distributed, the updated lists may be used to send the emails using an email delivery
server.

=== Privacy

Privacy is a very important topic, especially when dealing with visitor data. For example, new legislation such as the
https://eugdpr.org[GDPR] imposes strict restrictions on how visitor data collection should be processed. It is therefore
very important that the CDP specification provide standardized ways of complying with more and more stringent
requirements.

image::images/cdp-privacy-usecase.svg["Privacy use case diagram"]

In the above use case we illustrate the support of consent management that is available in CDP-compliant systems. A
visitor profile may store the state of consents (granted or not) and these may be updated by using specialized event
types.

Other use cases for privacy include profile downloading, being able to anonymize visitor data, as well as deleting
profiles.

=== A/B testing

CDP systems may also be used to deliver A/B testing experiences. In this use case, the CDP server will use the visitor
profile information by updating it with the variants that the visitor has been exposed to, effectively "classifying" the
visitor into a sub-group.

image::images/cdp-abtesting-usecase.svg["A/B testing use case diagram"]

In the above illustration, this use case is implemented by using a CMS to deliver the different variants of content that
are hidden by default. After that, the CDP is asked whether the profile is in variant A or B, which might be implemented
in different fashions but they will be remembered by the CDP for future displays.

== API Reference

The Customer Data Platform (CDP) standard is built around a set of concepts, domain objects and services for interacting with them.
This is represented through a strongly typed API defined through GraphQL Types, Queries, Mutations and Subscriptions.

This chapter describes the API in detail.

NOTE: The most efficient way to expore the GraphQL API is by starting the sample CDP server TODO

*Scalars*

GraphQL provides several basic value types that are used extensively in this specification, for instance Int and String.
However, the CDP specification is also handling other value types in a similar fashion. As such, the following scalars have been added:

[source,graphql]
----
include::{sourcedir}/schemas/cdpglobal.js[lines=5..16]
----

=== Clients

The CDP GraphQL API is not intended to be exposed publicly, but only made accessible to specific authorized clients.

Client means any software that interacts directly with the Customer Data Platform.
A Customer Data Platform typically holds personal data, as such implementers are urged to place strong control over which clients can connect to a Customer Data Platform.
In any case, it should not be possible for unauthorized clients to access the Customer Data Platform API.

Examples of clients are:

* Cookie-based tracker for website(s)
* Integration with your CRM
* Integration with your Identity System

Each Client is responsible for uniquely identifying visitors, for instance through the use of a cookie on the website, a customer ID in the CRM or a user ID in the Identity system.
The Customer Data Platform requires <<profileIDs>> to be unique within every client.
For instance, if a client is used to track visitors across multiple websites, it should aim to re-use the same profileID across all of them, for the same visitor.

NOTE: The standard does not specify Queries or Mutations for creating or retrieving Clients in the CDP specification, as this is considered an implementation-specific feature.
For any CDP implementation, a Client must be pre-defined in the CDP server before it can access the API.

NOTE: Queries, mutations and subscriptions for Clients are not defined by the standard, and as such implementation specific

==== CDP_Client

[source,graphql]
----
include::{sourcedir}/schemas/client.js[lines=2..6]
----


=== Sources
Sources are used to secure unique identifier per client.
For instance, if a CRM is used as a source it will have unique identifiers for its respective profile records.
As the CDP server collects data from multiple records, the combination of source and identifier provides a globally unique, but consistent identifier for CDP to process.

==== CDP_Source

[source,graphql]
----
include::{sourcedir}/schemas/sources.js[lines=2..5]
----

==== CDP_SourceInput

[source,graphql]
----
include::{sourcedir}/schemas/sources.js[lines=7..10]
----

* *source* The "system" source ID is reserved for internal use by CDP server (TODO call this CDP instead?).
* *thirdParty* Optional, indicates that the source is a third party (useful for privacy regulations such as GDPR)


==== CDP_Query

.Source related queries
[source,graphql]
----
include::{sourcedir}/schemas/sources.js[lines=12..14]
----

==== CDP_Mutation

.Source related mutations
[source,graphql]
----
include::{sourcedir}/schemas/sources.js[lines=16..19]
----

=== Sessions
When individuals interact, clients may enrich the data associated with interaction by specifying sessions.
For instance, a session may start when a user loads a specific app, and end when he closes it.

TODO: Mandatory/Automatic/????

==== CDP_SessionState

[source,graphql]
----
include::{sourcedir}/schemas/sessions.js[lines=2..7]
----

==== CDP_UpdateSessionStateInput

[source,graphql]
----
include::{sourcedir}/schemas/sessions.js[lines=9..11]
----


=== Profiles
Profiles are in many ways the essence of CDP.
A Customer Data Platform dynamically builds profiles from events that occur over time.

A Profile can be created from an anonymous visitor on a webpage, or populated from an identity system or maybe a CRM - or the combination of all of them.

Different <<Clients>> like a website tracking script, CRM or identity system can be configured to feed <<Events>> to the Customer Data Platform.

The Customer Data Platform is responsible for building profiles based on the provided identifiers and the stream of events coming from each Client.

NOTE: Profiles are not created like many other objects, but are rather composed through a chain of events.

NOTE: Specification implementers are encouraged to implement interfaces for importing profilesSchema??


==== CDP_ProfileID

[source,graphql]
----
include::{sourcedir}/schemas/profiles.js[lines=5..8]
----

==== CDP_ProfileIDInput

[source,graphql]
----
include::{sourcedir}/schemas/profiles.js[lines=10..13]
----

* *id* ID must be unique within the source

==== CDP_ProfileInterface
This interface is also used by <<Personas>>

[source,graphql]
----
include::{sourcedir}/schemas/profiles.js[lines=18..26]
----

* *profileIDs* A single profile may consist of multiple id's as profiles are being merged. TODO:?? The CXS server may generate a system profile ID and expose it here


==== CDP_Profile

[source,graphql]
----
include::{sourcedir}/schemas/profiles.js[lines=27..39]
----

==== CDP_UpdateProfileEventInput

[source,graphql]
----
include::{sourcedir}/schemas/profiles.js[lines=42..45]
----


==== CDP_Query

.Profile queries
[source,graphql]
----
include::{sourcedir}/schemas/profiles.js[lines=47..51]
----

==== CDP_Mutation

.Profile mutations
[source,graphql]
----
include::{sourcedir}/schemas/profiles.js[lines=53..57]
----


=== Properties

A Property is essentially data stored in a key-value format.
A single property can hold a single value, or an array of values.
Each property has a specific valueType to limit what kind of values it may hold.
These are ``Identifier``,``String``, ``Int``, ``Float``, ``Date``, ``Boolean``, ``GeoPoint`` and ``Set``.

Some example properties:

* someString : "Serge"
* someDate : "1996-12-19"
* someInteger : 1337
* location : "lat,lon"
* arrayOfStrings : ["This", "is", "nice"]
* setOfProperties : {prompt : "hello", response : "yo"}

The valueType Set is special, as it enables nested properties and a tree-structure of properties.
I.e. from the example above: "setOfProperties.response" would hold the value "yo"

Properties are defined by a PropertyType.
PropertyTypes are used to dynamically define schemas in the Customer Data Platform.
A propertyType essentially specifies:

* the property name
* the valueType of the property (Identifier, String, Int, Float, Date, Boolean, GeoPoint and Set)
* minimum occurences of values (a property may hold one or more values)
* maximum occurences

Since the CDP api is defined using GraphQL,
the API is dynamically updated when the propertyTypes are changed.

==== CDP_Property

TODO: Defines the basic implementations for each valueType.
Simplifies use and provides strong typing in GraphQL.

[source,graphql]
----
include::{sourcedir}/schemas/properties.js[lines=5..12]
----

ID:: must be in a format that's acceptable as a GraphQL field name (/[_A-Za-z][_0-9A-Za-z]*/) , and we recommend to prefix it to avoid conflicts, i.e acme_pageView, acme_click. "cdp_" is reserved.
minOccurences:: Default = 0. For minOccurrences > 1 the property can hold multiple values in preserved order. minOccurences = 1 indicates the property is mandatory.
maxOccurences:: Default = 1. maxOccurences = 0 indicates no limit. maxOccurences must be higher than minOccurences.
tags:: TODO: User generated tags.
systemTags:: TODO: address, social.
personalData:: Default = true.


==== CDP_PropertyInput

This type is a workaround for missing inheritance in GraphQL.
Only one field may be used at a time, all other fields must be null.

[source,graphql]
----
include::{sourcedir}/schemas/properties.js[lines=17..26]
----

==== CDP_BooleanProperty

[source,graphql]
----
include::{sourcedir}/schemas/properties/boolean.js[lines=2..10]
----

==== CDP_BooleanPropertyInput

[source,graphql]
----
include::{sourcedir}/schemas/properties/boolean.js[lines=12..20]
----


==== CDP_DateProperty

[source,graphql]
----
include::{sourcedir}/schemas/properties/date.js[lines=5..13]
----

==== CDP_DatePropertyInput

[source,graphql]
----
include::{sourcedir}/schemas/properties/date.js[lines=15..23]
----


==== CDP_FloatProperty

[source,graphql]
----
include::{sourcedir}/schemas/properties/float.js[lines=2..12]
----

==== CDP_FloatPropertyInput

[source,graphql]
----
include::{sourcedir}/schemas/properties/float.js[lines=14..24]
----


==== CDP_GeoPointProperty

[source,graphql]
----
include::{sourcedir}/schemas/properties/geopoint.js[lines=5..13]
----

==== CDP_GeoPointPropertyInput

[source,graphql]
----
include::{sourcedir}/schemas/properties/geopoint.js[lines=15..23]
----

==== CDP_IdentifierProperty

[source,graphql]
----
include::{sourcedir}/schemas/properties/identifier.js[lines=5..14]
----

==== CDP_IdentifierPropertyInput

[source,graphql]
----
include::{sourcedir}/schemas/properties/identifier.js[lines=16..25]
----


==== CDP_IntProperty

[source,graphql]
----
include::{sourcedir}/schemas/properties/int.js[lines=2..12]
----

==== CDP_IntPropertyInput

[source,graphql]
----
include::{sourcedir}/schemas/properties/int.js[lines=14..24]
----


==== CDP_StringProperty

[source,graphql]
----
include::{sourcedir}/schemas/properties/string.js[lines=2..11]
----

==== CDP_StringPropertyInput

[source,graphql]
----
include::{sourcedir}/schemas/properties/string.js[lines=13..22]
----


==== CDP_SetProperty

[source,graphql]
----
include::{sourcedir}/schemas/properties/set.js[lines=5..13]
----

==== CDP_SetPropertyInput

[source,graphql]
----
include::{sourcedir}/schemas/properties/set.js[lines=15..23]
----

=== ProfileProperties

To create a schema for <<Profiles>>, we need a globally defined set of properties.

Collectively, all ProfileProperties defines the schema of properties that can be used by any profile in the Customer Data Platform.

This enables administrators and developers to build and maintain a consistent data model for profiles across different <<Clients>>.
Any data imported to the system must be mapped to a corresponding ProfileProperties.

==== CDP_ProfileProperties

Profiles are normally updated through events.
The history of external or internal profile modifications is accessible through the profile update events.
CDP must also specify a way to provide subscriptions on profile modifications so that external systems can retrieve the profile modifications.

The flow looks like this :
Real Event --> Source -> Mapping -> Profile

Profile merges are optional in the CDP specification. They may be supported by using a property defined as an identifier as a merge key (multiple merge keys may of course exist) to merge multiple profiles. The resulting merged profile MUST contain all the source profile IDs of the merged profiles as well as the merged profile data. The original profiles that were merged may be flagged or deleted, this is implementation specific.

[source,graphql]
----
include::{sourcedir}/schemas/profiles.js[lines=30..33]
----

==== CDP_ProfilePropertiesInput

TODO: Is this actually available? If so we don't need events to update profiles?

[source,graphql]
----
include::{sourcedir}/schemas/profiles.js[lines=36..39]
----

TODO Explain how the property types generated the fields in the CDP_ProfileProperties using the samples below

[source,graphql]
----
"""
This type is dynamically generated from the defined ProfileProperties. firstName, lastName, sample_Location and sample_Address are just examples of how this might look if these profileProperties were actually defined.
"""
type CDP_ProfileProperties {
  firstName : String
  lastName : String
  sample_Location : Sample_Location
  sample_Address : Sample_Address
}

"""
Sample type generated from ProfileProperties definition
"""
type Sample_Location {
  latitude : Float,
  longitude : Float
}

"""
Sample type generated from ProfileProperties definition
"""
type Sample_StreetNumber {
  streetNumber : Int,
  prefix : String,
  postfix : String
}

"""
Sample type generated from ProfileProperties definition
"""
type Sample_Address {
  streetName : String,
  sample_StreetNumber : Sample_StreetNumber,
  citySubDivisions : [String]
  city : String,
  postalCode : String,
  countrySubvisions : [String]
  country : String
}
----

==== CDP_Query



==== CDP_Mutation


=== Events
Events are what drives the Customer Data Platform forward.
Events are collected from different Clients, such as a specific website, beacons, commerce systems or a CRM.

A single Client might still produce many different profiles for a "real person".
For instance - if a visitor uses different devices on a single web page, each device will produce a new profile, with a unique profileID.

As such, Customer Data Platforms implementations SHOULD support profile merges.

As profiles evolve over time, the Customer Data Platform may discover that two profiles actually represent the same individual i.e. if the same e-mail address is registered in both profiles, or if the user in on both his devices. This may then result in a profile merge.
During a profile merge, the Customer Data Platform will link two (or more) separate profiles together.
In order to keep event history and avoid re-processing of data, the merge process must not affect the existing and unique profileIDs.
This is why profiles are defined to have multiple profileIDs.

Example: As such, when visitors on a website are tracked through a cookie (defining the profileID), the cookie will remain the same even if the profile is merged.

The Customer Data Platform is essentially interested in "User behavioral events".
An event could be anything from someone clicking a link, to performing a transaction or consenting to use of his/hers information.
Events are streamed or delivered from authorized <<Clients>> to the Customer Data Platform.

As an example: Imagine an e-commerce site with a client that collect events from its visitors.
When a visitor browses the site with his laptop, the client assigns a cookie to his/her browser and starts feeding events to the CDP API.
As the visitor click on some product links, and maybe fills in a form that includes e-mail. CDP will gradually populate a profile, using the cookie value as an ID.
At a later point, the same visitor picks up a different device and returns to the site. As the client cannot know this is the same individual, a new cookie is generated, and a new profile starts to build up.

A single client may be used to track <<Events>> from a number of different websites, where each website can be tagged with a source.
Sources provide a way to identify the exact origin of the events beyond the client.
As such, sources are comparable to siteID's in Google Analytics.

==== CDP_Event

[source,graphql]
----
include::{sourcedir}/schemas/events.js[lines=2..11]
----

==== CDP_EventInput

[source,graphql]
----
include::{sourcedir}/schemas/events.js[lines=18..34]
----

==== CDP_Query

.Event queries
[source,graphql]
----
include::{sourcedir}/schemas/events.js[lines=37..38]
----

==== CDP_Mutation

.Event mutations
[source,graphql]
----
include::{sourcedir}/schemas/events.js[lines=42..42]
----

=== EventTypes

An event must be of a specific type.
EventTypes are implementation specific, with the exception of the standard EventTypes.

The API must include all EventTypes that are available for the specific CDP implementation.
Implementers are encouraged to make EventTypes pluggable, for flexibility.

It is recommended that pluggable EventTypes are registered with a prefix, to avoid naming conflicts.

Here are examples of custom EventTypes:

.Sample EventTypeInput for Page Views
[source,GraphQL]
----
input PageViewEventInput {
  pageID : String,
  pageUrl : String,
  referrer : String,
  userAgent : String
}
----

.Sample EventTypeInput for profile update
[source,GraphQL]
----
input profileUpdateEventInput : {
  firstName : String,
  lastName : String,
  email : String,
  address : AddressInput,
  twitter : String
}
----

.Sample EventTypeInput for crm updates
[source,javascript]
----
input crmLeadUpdate {
  leadStatus : String,
  leadID : String,
  firstName : String,
  lastName : String,
  email : String
}
----

TODO Cleanup the list of example event types

Example event types include :

- Updating profile properties, needs to match the profile properties definitions
- Updating consent ( see http://ec.europa.eu/ipg/basics/legal/cookies/index_en.htm )
- Transaction (generic)
- Like (“user likes a product”)
- Dislike (“visitor dislikes a comment”)
- Abuse, “user reports abuse on a page”
- Rate (score in percent) “user rates product 4 out of 5 stars”
- Vote
- Download (“user downloaded a digital product”)
- Register/Submission
- Login
- Logout
- RequestFriendship
- AcceptFriendship
- DenyFriendship
- Click
- View
- Contribute (comment, blog etc?)
- Conversion (purchase, download, signs up for a service
- Session start
- Session paused
- Session resumed
- Session end
- Opt-in / opt-out of a list



=== Consents

New legislation and stricter rules for use of personal data is already here (i.e. GDPR).
As such, consents are inherently more important to ensure you are using and storing data in compliance with policies.

Consents hold an identifier that uniquely identifies the consent across your systems.

Consents are given and revoked through events. This means that the CDP specification defines reserved property types for granting and revoking consents.

TODO:

[source,graphql]
----
Do Not Track is a special case, because it cannot be handled using the content management since we cannot
track the user connect to the context server in any way. In this case, profile ID cookies should never be
generated, and each new request will be treated as a separate visit.

Tracking is seperated from cookie identification. For example we could have a form that has an opt-in checkbox
to "remember" the user, but NOT tracking his behavior, so that when he fills another form, pre-fill could happen,
or a single form submission could be handled.

    https://onetrust.com/nobody-likes-cookie-pop-ups-browser-based-consent-eprivacy-regulation/

Can we leverage OAuth 2 autorization scopes here ? Consent types are very similar to OAuth 2 authorization scopes.

Examples:
{
  sourceId : "jahia.com",
  type: {name:"send-to-salesforce"},
  grant: ALLOW
  grantDate : 3498734899
  # no revoke date means it will not expire or defaults to system or legal standard (GDPR)
}
{
  sourceId : "jahia.com",
  type : {name:"newsletter-subscription-latestNews"},
  grant: DENY
  grantDate : 3498734899
  # no revoke date means it will not expire or defaults to system or legal standard (GDPR)
}

Consent Types may include:
- tracking
- list membership
- newsletter membership
- access to camera
- access to friends / contacts data
- access to medical records
- send sms
- call you
- send personal data to third parties
- send anonymous data to third parties

CXS Consent types include:
- allow tracking
-
(for GDPR controllers / processors ?)

Consent types are not defined in the specification, only the format of the type identifier
should use a URI convention. Some URIs could actually be URLs and point to real resource that would give the
semantics of the consent type. Types are not globally unique, a combination of view and types are globally unique
and context server implementations may use "global" or "system" views to share types.
----

==== CDP_ConsentStatus

Uniquely specifies the status of any given Consent

[source,graphql]
----
include::{sourcedir}/schemas/consents.js[lines=2..6]
----


==== CDP_Consent

CDP_Consent represents a persisted Consent, always attached to a specific profile.

[source,graphql]
----
include::{sourcedir}/schemas/consents.js[lines=13..23]
----

==== CDP_ConsentInput

TODO: What are Tokens, and how are they used?
TODO: Write about "type"

[source,graphql]
----
include::{sourcedir}/schemas/consents.js[lines=25..30]
----

==== CDP_UpdateConsentEvent

Standard EventType to create or update Consents.

[source,graphql]
----
include::{sourcedir}/schemas/consents.js[lines=33..35]
----


=== Interests

An important use-case for the Customer Data Platform is to determine a profiles "Interests".
Whenever the Customer Data Platform registers an events that are associated with one or more <<Topics>>, this will affect the profile's interest for the specific Topic.
A profiles interest in a specific topic is measured between 0-1, where 1 is maximum. As such 0,5 would indicate a higher interest than 0,35.

The algorithm for how a Customer Data Platform scores and interest is implementation specific
- but implementations should also take care of automatically decreasing interest over time, unless new and relevant events occur.

Example interests for products from a car manufacturer might be:

*  Model S = 0.1
*  Model 3 = 0.3
*  Model X = 0.9


==== CDP_Interest

[source,graphql]
----
include::{sourcedir}/schemas/interests.js[lines=2..10]
----

score:: will be between 0.0 to 1.0


=== Filters

Filters are widely used in CDP, and enable querying profiles, events, and other CDP objects.
Filters are designed to be easy to use for administrators and marketeers in visual user interfaces, but also in terms of technical implementation.

Filters are essentially composed from basic property comparison expressions, and may be chained with the operators AND and OR, where AND is used by default.

A single filter may only operate on a specified CDP object (i.e. profile or event).

The following comparison operators are available:

.Operator availability for property value types
[options="header"]
|=============================================================
|Operators |Identifier|String|Int|Float|Date|Boolean|GeoPoint|
|equals    |x         |x     |x  |x    |x   |x      |x       |
|startsWith|          |x     |   |     |    |       |        |
|endsWith  |          |x     |   |     |    |       |        |
|contains  |          |x     |   |     |    |       |        |
|regexp*   |          |x     |   |     |    |       |        |
|lt        |          |      |x  |x    |x   |       |        |
|lte       |          |      |x  |x    |x   |       |        |
|gt        |          |      |x  |x    |x   |       |        |
|gte       |          |      |x  |x    |x   |       |        |
|distance  |          |      |   |     |    |       |x       |
|between*  |          |      |x  |x    |x   |       |        |
|=============================================================

* optional operators

As we are expressing filters through GraphQL, filters will always be strongly typed.
I.e. if the property "firstName" with valueType string is available, the following options can be used:

  firstName_equals
  firstName_startsWith
  firstName_endsWith
  firstName_contains
  firstName_regexp (optional)

Below are some basic filter examples:

  { "firstName_equals" : "Serge" }

  { "birthDate_greaterThan" : "1970-01-01" }

  { "location_distance" : {
    "center" : { "longitude" : 59.91273, "latitude": 10.74609 },
    "unit" : "KILOMETERS",
    "distance" : 5
    }
  }

  {
    "or" : [
      { "firstName_equals" : "Serge" },
      { "birthDate_greaterThan" : "1970-01-01" }
    ]
  }

==== Ordering

OrderBy is used in combination with filters and lets you sort the result based on properties available for the returned objects.

Example:

  "orderBy": [{
    "property": "firstName",
    "order": "ASC"
    }
  ]


===== CDP_SortOrder

Enumeration of allowed sorting operators

[source,graphql]
----
include::{sourcedir}/schemas/filters.js[lines=2..6]
----

===== CDP_OrderByInput

[source,graphql]
----
include::{sourcedir}/schemas/filters.js[lines=8..11]
----

fieldName:: Specify the field to sort by, i.e. "endTime", "properties.location"

===== CDP_DateFilter

[source,graphql]
----
include::{sourcedir}/schemas/filters.js[lines=13..18]
----

===== CDP_DateFilterInput

[source,graphql]
----
include::{sourcedir}/schemas/filters.js[lines=20..25]
----

===== TODO

What are these?

[source,graphql]
----
include::{sourcedir}/schemas/filters.js[lines=27..43]
----


==== EventFilters

EventFilters are a specific version of filters for querying events.

Example: Filter for identifying events of type `transaction` within the last 30 days.

  {
    "properties" : {
        "timestamp_between" : { "after" : "2018-06-28T05:25:28+00:00", "before" : "2018-06-28T06:25:28+00:00", includeBefore : false, includeAfter : true },
        "cdp_UpdateProfile" : {
          "updateProperties": {
            "firstName_startsWith" : "T"
            "lastName_endsWith" : "d"
          }
        }
    },
    "eventOccurrence": { "eventId": "transaction",   "count": 1,  "afterTime": "now-30d" }}
  }


===== CDP_EventFilter

[source,graphql]
----
include::{sourcedir}/schemas/eventfilters.js[lines=2..12]
----


===== CDP_EventFilterInput

[source,graphql]
----
include::{sourcedir}/schemas/eventfilters.js[lines=14..24]
----


==== ProfileFilters

Profile Filters are slightly more complex than <<EventFilters>>.
As profileFilter are composed from the following:

===== CDP_ProfileFilter

[source,graphql]
----
include::{sourcedir}/schemas/profilefilters.js[lines=2..8]
----

asString:: Example: profile.test = 'testValue' AND eventOccurrence('pageView') = 10


===== CDP_ProfileFilterInput

[source,graphql]
----
include::{sourcedir}/schemas/profilefilters.js[lines=10..16]
----

===== CDP_ProfilePropertiesFilter

[source,graphql]
----
include::{sourcedir}/schemas/profilefilters.js[lines=21..25]
----

===== CDP_ProfilePropertiesFilterInput

[source,graphql]
----
include::{sourcedir}/schemas/profilefilters.js[lines=35..40]
----

===== CDP_ProfileEventsFilter

[source,graphql]
----
include::{sourcedir}/schemas/profilefilters.js[lines=33..40]
----

===== CDP_ProfileEventsFilterInput

[source,graphql]
----
include::{sourcedir}/schemas/profilefilters.js[lines=42..49]
----


==== Management object filters

===== CDP_SegmentFilterInput

[source,graphql]
----
include::{sourcedir}/schemas/managementfilters.js[lines=2..9]
----

===== CDP_ListFilterInput

[source,graphql]
----
include::{sourcedir}/schemas/managementfilters.js[lines=11..17]
----

===== CDP_TopicFilterInput

[source,graphql]
----
include::{sourcedir}/schemas/managementfilters.js[lines=19..25]
----

=== Views

Views provide a way of grouping administrative objects in the Customer Data Platform.
<<Profiles>>, <<Events>> and <<Consents>> are all collected and stored globally,
but other items are typically handled by administrators or marketeers, and benefit from being grouped into different views to simplify handling.

<<Lists>>, <<Segments>>, <<Topics>> and <<Personas>> are all tagged with Views.


==== CDP_View

[source,graphql]
----
include::{sourcedir}/schemas/views.js[lines=2..5]
----

==== CDP_ViewInput

[source,graphql]
----
include::{sourcedir}/schemas/views.js[lines=7..9]
----


==== CDP_Query

.View queries
[source,graphql]
----
include::{sourcedir}/schemas/views.js[lines=27..28]
----

==== CDP_Mutation

.View mutations
[source,graphql]
----
include::{sourcedir}/schemas/views.js[lines=32..33]
----



=== Personas

A persona is a concept used by marketeers to visualize one or more target customers, and simplify personalization and targeting of content.

In CDP, personas are essentially "dummy" profiles with the primary purpose of testing or emulating a real profile.
A common use-case would be testing personalized content in a CMS or a newsletter.

Personas and their fields can be explicitly created, where real profiles are built from a stream of events.

==== CDP_Persona

[source,graphql]
----
include::{sourcedir}/schemas/personas.js[lines=5..16]
----

==== CDP_PersonaInput

[source,graphql]
----
include::{sourcedir}/schemas/personas.js[lines=18..27]
----

==== CDP_Query

.Persona queries
[source,graphql]
----
include::{sourcedir}/schemas/personas.js[lines=30..31]
----

==== CDP_Mutation

.Persona mutations
[source,graphql]
----
include::{sourcedir}/schemas/personas.js[lines=35..36]
----


=== Lists

Lists are explicitly created and named in the Customer Data Platform. Profiles may then be added to a list, and later opt out if desired.
Whenever a profile opts out of a list, that information will also be stored. This prevents the profile from accidentally being added back to the list at a later point.

A common use-case for lists is creating a list for a campaign, and add the target profiles to the list as the campaign starts.

==== CDP_List

[source,graphql]
----
include::{sourcedir}/schemas/lists.js[lines=2..8]
----

id:: Cannot change and is usually server generated



==== CDP_ListInput

[source,graphql]
----
include::{sourcedir}/schemas/lists.js[lines=10..14]
----


==== CDP_UpdateListEvent

Standard Event to update profile membership for specified lists

[source,graphql]
----
include::{sourcedir}/schemas/lists.js[lines=17..20]
----

==== CDP_Query

.List queries
[source,graphql]
----
include::{sourcedir}/schemas/lists.js[lines=23..24]
----

==== CDP_Mutation

.List mutations
[source,graphql]
----
include::{sourcedir}/schemas/lists.js[lines=28..31]
----


=== Segments

Segments are similar to lists in that profiles may be in the segment, or not.
However, where profiles are explicitly added to lists, they are dynamically resolved to segments based on the filter defined in the segment.

Administrative users define segments through <<Filters>>.

Example segments:
* Rich europeans: Profiles in Europe with income above €100k
* Frequent buyer: Profiles that have completed more than 5 transactions in the last 3 months
* Etc


==== CDP_Segment

[source,graphql]
----
include::{sourcedir}/schemas/segments.js[lines=2..7]
----

==== CDP_SegmentInput

[source,graphql]
----
include::{sourcedir}/schemas/segments.js[lines=9..14]
----

==== CDP_Query

.Segment queries
[source,graphql]
----
include::{sourcedir}/schemas/segments.js[lines=17..18]
----

==== CDP_Mutation

.Segment mutations
[source,graphql]
----
include::{sourcedir}/schemas/segments.js[lines=22..23]
----


=== Topics

Topics represent the core entities of the business that is using the Customer Data Platform.
The Customer Data Platform aims to find correlation between profiles and the topics.
When such correlations are identified, it is called <<Interests>>.

CDP Administrators need to maintain a list of topics in order to obtain profile interests.
Profile interests is typically a core objective of Marketing activities, and targeting users with better content.

Example Topics for a car manufacturer might for instance be:

* "Model S"
* "Model 3"
* "Model X"

TODO: What about localization?


==== CDP_Topic

[source,graphql]
----
include::{sourcedir}/schemas/topics.js[lines=2..6]
----

==== CDP_TopicInput

[source,graphql]
----
include::{sourcedir}/schemas/topics.js[lines=8..12]
----

==== CDP_Query

.Topic queries
[source,graphql]
----
include::{sourcedir}/schemas/topics.js[lines=15..16]
----

==== CDP_Mutation

.Topic mutations
[source,graphql]
----
include::{sourcedir}/schemas/topics.js[lines=20..21]
----




=== Optimization

TODO: write an introduction to optimization

==== CDP_Object

[source,graphql]
----
include::{sourcedir}/schemas/optimizations.js[lines=2..5]
----

id:: Unique within each specified collection
collection:: TODO: Verify this - A way of classifying objects. Use URIs, e.g. schema.org (http://schema.org/Product) or reverse domain naming convention (org.acme.Product)


==== CDP_ObjectInput

[source,graphql]
----
include::{sourcedir}/schemas/optimizations.js[lines=7..10]
----

==== CDP_OptimizationResult

[source,graphql]
----
include::{sourcedir}/schemas/optimizations.js[lines=13..16]
----

==== CDP_ScoredObject

[source,graphql]
----
include::{sourcedir}/schemas/optimizations.js[lines=18..21]
----


==== CDP_OptimizationInput

Example : return list of products that the profile has viewed but not bought

[source,graphql]
----
include::{sourcedir}/schemas/optimizations.js[lines=23..28]
----

==== CDP_EventOccurenceBoostInput

Used to boost positively/negatively the algorithm based on event type and time span: i.e. return a list of products the profile has viewed in the last year

[source,graphql]
----
include::{sourcedir}/schemas/optimizations.js[lines=30..35]
----


==== CDP_AlgorithmInput

[source,graphql]
----
include::{sourcedir}/schemas/optimizations.js[lines=37..40]
----

==== CDP_RecommendationResult

[source,graphql]
----
include::{sourcedir}/schemas/optimizations.js[lines=42..45]
----

==== CDP_RecommendationInput

[source,graphql]
----
include::{sourcedir}/schemas/optimizations.js[lines=47..53]
----

== Security Considerations

TODO REMOVE: (Note: OASIS strongly recommends that Technical Committees consider issues that could affect security when implementing their specification and document them for implementers and adopters. For some purposes, you may find it required, e.g. if you apply for IANA registration.
While it may not be immediately obvious how your specification might make systems vulnerable to attack, most specifications, because they involve communications between systems, message formats, or system settings, open potential channels for exploit. For example, IETF \[RFC3552] lists “eavesdropping, replay, message insertion, deletion, modification, and man-in-the-middle” as well as potential denial of service attacks as threats that must be considered and, if appropriate, addressed in IETF RFCs.

In addition to considering and describing foreseeable risks, this section should include guidance on how implementers and adopters can protect against these risks
We encourage editors and TC members concerned with this subject to read Guidelines for Writing RFC Text on Security Considerations, IETF \[RFC3552], for more information.)


== Conformance

TODO REMOVE: (For the definition of "conformance clause," see OASIS Defined Terms.
See "Guidelines to Writing Conformance Clauses": http://docs.oasis-open.org/templates/TCHandbook/ConformanceGuidelines.html.)


== Appendix A. Acknowledgements

The following individuals have participated in the creation of this specification and are gratefully acknowledged:

Participants:

  * Participant Name, Affiliation | Individual Member
  * Participant Name, Affiliation | Individual Member

== Appendix B. Example Title

TODO: any additional appendices for non-normative text here

== Appendix C. Revision History

Revision 	Date 	Editor 	Changes Made
